<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>MCDU Checklists</title>

  <!-- PWA hooks -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#1b1b1b">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="MCDU">
  <link rel="apple-touch-icon" href="icon-192.png">

  <style>
    :root {
      --bg: #1b1b1b;
      --lcd: #000;
      --green: #00ff6a;
      --btn: #2b2b2b;
      --btnb: #3a3a3a;
    }

    html,
    body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace;
      color: #e8e8e8;
    }

    .wrap {
      max-width: 920px;
      margin: 0 auto;
      padding: 12px;
      padding-bottom: 24px;
    }

    .title {
      text-align: center;
      color: var(--green);
      background: var(--lcd);
      border: 2px solid #333;
      border-radius: 8px;
      padding: 8px;
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .screen {
      display: grid;
      grid-template-columns: auto 1fr 1fr auto;
      gap: 8px;
      align-items: stretch;
      margin-top: 8px;
    }

    .lsk,
    .rsk {
      background: var(--btn);
      border: 1px solid var(--btnb);
      border-radius: 6px;
      color: #e8e8e8;
      padding: 8px 10px;
      min-width: 52px;
      text-align: center;
      touch-action: manipulation;
      user-select: none;
    }

    .lcell,
    .rcell {
      background: var(--lcd);
      color: var(--green);
      padding: 8px 10px;
      border: 1px solid #333;
      min-height: 42px;
      display: flex;
      align-items: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      box-sizing: border-box;
    }

    .lcell {
      justify-content: flex-start;
    }

    .rcell {
      justify-content: flex-end;
    }

    .sep {
      color: var(--green);
      background: var(--lcd);
      border: 1px solid #333;
      padding: 8px 10px;
      margin-top: 8px;
      box-sizing: border-box;
      text-align: center;
    }

    /* scratchpad with hidden input overlay */
    .scratchpad-wrapper {
      position: relative;
      margin-top: 8px;
    }

    .scratch {
      color: var(--green);
      background: var(--lcd);
      border: 1px solid #333;
      padding: 8px 10px;
      min-height: 42px;
      box-sizing: border-box;
    }

    .scratch-input {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      /* invisible input */
      border: none;
      background: transparent;
      color: transparent;
      /* don't show text */
      caret-color: transparent;
      /* hide blinking caret */
      outline: none;
    }

    .kbd {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      gap: 8px;
      margin-top: 12px;
    }

    .key {
      background: var(--btn);
      border: 1px solid var(--btnb);
      border-radius: 6px;
      color: #e8e8e8;
      padding: 12px 8px;
      text-align: center;
      touch-action: manipulation;
      user-select: none;
    }

    .hint {
      opacity: .7;
      font-size: 12px;
      margin-top: 8px;
      text-align: center;
    }

    @media (hover:hover) {

      .key:active,
      .lsk:active,
      .rsk:active {
        filter: brightness(1.1);
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div id="title" class="title">MCDU MENU</div>

    <!-- 6 rows: [L][Left][Right][R] -->
    <div id="screen" class="screen"></div>

    <div class="sep">——————————————</div>

    <!-- Scratchpad + hidden input for native keyboard -->
    <div class="scratchpad-wrapper">
      <div id="scratch" class="scratch">—SCRATCHPAD—</div>
      <input id="scratchInput" class="scratch-input" type="text" autocomplete="off" autocorrect="off"
        autocapitalize="characters" />
    </div>

    <!-- keypad -->
    <div id="kbd" class="kbd"></div>
    <div class="hint">Tip: Tap the scratchpad or use keypad; Share → Add to Home Screen for app mode.</div>
  </div>

  <script>
    /* ========= State & storage ========= */
    const STORAGE_KEY = "mcduChecklistsV1";

    function loadChecklists() {
      try {
        const s = localStorage.getItem(STORAGE_KEY);
        if (!s) return [];
        const data = JSON.parse(s);
        if (!Array.isArray(data)) return [];
        return data;
      } catch {
        return [];
      }
    }
    function saveChecklists() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state.checklists));
      } catch { }
    }

    function uuid() {
      return "xxxx-4xxx-yxxx".replace(/[xy]/g, c => {
        const r = Math.random() * 16 | 0;
        const v = c === "x" ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    const state = {
      page: "MENU",
      scratch: "",
      checklists: loadChecklists(),  // [{id,name,items:[...]}]
      select: null,
      view: null,
      edit: null,
      new: null
    };

    /* ========= UI creation ========= */
    const titleEl = document.getElementById("title");
    const scratchEl = document.getElementById("scratch");
    const scratchInput = document.getElementById("scratchInput");
    const screenEl = document.getElementById("screen");
    const lLabels = [];
    const rLabels = [];

    // focus scratch input when tapping the scratch area
    scratchEl.addEventListener("click", () => scratchInput.focus());

    for (let i = 0; i < 6; i++) {
      const lbtn = document.createElement("button");
      lbtn.className = "lsk";
      lbtn.textContent = `L${i + 1}`;
      lbtn.onclick = () => onLsk("L", i + 1);

      const lcell = document.createElement("div");
      lcell.className = "lcell";

      const rcell = document.createElement("div");
      rcell.className = "rcell";

      const rbtn = document.createElement("button");
      rbtn.className = "rsk";
      rbtn.textContent = `R${i + 1}`;
      rbtn.onclick = () => onLsk("R", i + 1);

      screenEl.appendChild(lbtn);
      screenEl.appendChild(lcell);
      screenEl.appendChild(rcell);
      screenEl.appendChild(rbtn);

      lLabels.push(lcell);
      rLabels.push(rcell);
    }

    /* keypad */
    const kbdEl = document.getElementById("kbd");
    const keyRows = [
      ["A", "B", "C", "D", "E", "F", "G", "H", "I"],
      ["J", "K", "L", "M", "N", "O", "P", "Q", "R"],
      ["S", "T", "U", "V", "W", "X", "Y", "Z", "/"],
      ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
      [".", "0", "SP", "CLR", "DEL", "EXEC", "NEXT", "PREV", "MENU"]
    ];
    for (const row of keyRows) {
      for (const key of row) {
        const b = document.createElement("div");
        b.className = "key";
        b.textContent = key;
        b.onclick = () => onKey(key);
        kbdEl.appendChild(b);
      }
    }

    /* ========= Page navigation helpers ========= */

    function setMenuPage() {
      state.page = "MENU";
      state.select = state.view = state.edit = state.new = null;
      render();
    }

    function setSelectPage(mode) {
      state.page = "SELECT";
      state.select = { mode, offset: 0 };
      state.view = state.edit = state.new = null;
      render();
    }

    function setViewPage(id) {
      const cl = state.checklists.find(c => c.id === id);
      if (!cl) { info("NOT FOUND"); setMenuPage(); return; }
      state.page = "VIEW";
      state.view = {
        id,
        offset: 0,
        checked: new Array(cl.items.length).fill(false)
      };
      state.select = state.edit = state.new = null;
      render();
    }

    function setNewPage() {
      state.page = "NEW";
      state.new = { name: "", items: [], offset: 0 };
      state.select = state.view = state.edit = null;
      render();
    }

    function setEditPage(id) {
      const cl = state.checklists.find(c => c.id === id);
      if (!cl) { info("NOT FOUND"); setMenuPage(); return; }
      state.page = "EDIT";
      state.edit = { id, name: cl.name, items: cl.items.slice(), offset: 0 };
      state.select = state.view = state.new = null;
      render();
    }

    /* ========= Rendering ========= */

    function render() {
      const { title, rows } = renderPage();

      titleEl.textContent = title;
      const displayRows = rows.concat(Array(6).fill(["", ""])).slice(0, 6);
      displayRows.forEach(([lt, rt], i) => {
        lLabels[i].textContent = (lt ?? "").slice(0, 24);
        rLabels[i].textContent = (rt ?? "").slice(0, 24);
      });

      const sp = state.scratch || "—SCRATCHPAD—";
      scratchEl.textContent = sp;
      if (scratchInput.value !== state.scratch) {
        scratchInput.value = state.scratch;
      }

      saveChecklists(); // persist whenever state changes
    }

    function renderPage() {
      switch (state.page) {
        case "MENU": return renderMenu();
        case "SELECT": return renderSelect();
        case "VIEW": return renderView();
        case "NEW": return renderNew();
        case "EDIT": return renderEdit();
        default: return { title: "MCDU", rows: Array(6).fill(["", ""]) };
      }
    }

    function renderMenu() {
      const rows = [
        ["", "SELECT CHECK LIST >"],
        ["", "NEW CHECK LIST    >"],
        ["", "EDIT CHECK LIST   >"],
        ["", ""],
        ["", ""],
        ["", ""],
      ];
      return { title: "MCDU MENU", rows };
    }

    function renderSelect() {
      const files = state.checklists;
      const offset = state.select?.offset || 0;
      const rows = Array(6).fill(["", ""]);

      if (!files.length) {
        rows[0] = ["NO CHECKLISTS", ""];
        rows[5] = ["< MENU", ""];
        return { title: "SELECT CHKLST", rows };
      }

      const chunk = files.slice(offset, offset + 5);
      chunk.forEach((cl, i) => {
        rows[i] = [`< ${cl.name}`, ""];
      });

      let hint = "";
      if (offset > 0) hint += "PREV ";
      if (offset + 5 < files.length) hint += "NEXT";
      rows[5] = ["< MENU", hint.trim()];

      return { title: state.select.mode === "edit" ? "EDIT CHKLST" : "SELECT CHKLST", rows };
    }

    function renderView() {
      const v = state.view;
      const cl = state.checklists.find(c => c.id === v.id);
      if (!cl) return { title: "CHECK LIST", rows: Array(6).fill(["", ""]) };

      const rows = Array(6).fill(["", ""]);
      const start = v.offset;
      const chunk = cl.items.slice(start, start + 5);

      chunk.forEach((item, i) => {
        const idx = start + i;
        const done = v.checked[idx] ? "DONE" : "";
        rows[i] = [item, done]; // rows 0..4 mapped to L1..L5
      });

      const hints = [];
      if (cl.items.length) hints.push("L1-L5=TOGGLE");
      if (v.offset > 0) hints.push("PREV");
      if (v.offset + 5 < cl.items.length) hints.push("NEXT");
      rows[5] = ["< MENU", hints.join("  ")];

      return { title: cl.name || "CHECK LIST", rows };
    }

    function renderNew() {
      const n = state.new;
      const rows = Array(6).fill(["", ""]);

      // L1 line: name
      rows[0] = [n.name || "< NAME (L1)", ""];

      // L2-L6 lines: items (paged)
      for (let i = 0; i < 5; i++) {
        const idx = n.offset + i;
        const number = idx + 1;
        let text;
        if (idx < n.items.length) {
          text = n.items[idx] || `< ITEM ${number} (L${i + 2})`;
        } else {
          text = `< ITEM ${number} (L${i + 2})`;
        }
        rows[i + 1] = [text, ""];
      }

      const page = n.offset / 5 + 1;
      let right = `P${page}  SAVE (R6)`;
      rows[5] = ["", right];
      return { title: "NEW CHKLST", rows };
    }

    function renderEdit() {
      const e = state.edit;
      const rows = Array(6).fill(["", ""]);

      // L1 line: name
      rows[0] = [e.name || "< NAME (L1)", ""];

      // L2-L6 lines: items (paged)
      for (let i = 0; i < 5; i++) {
        const idx = e.offset + i;
        const number = idx + 1;
        let text;
        if (idx < e.items.length) {
          text = e.items[idx] || `< ITEM ${number} (L${i + 2})`;
        } else {
          text = `< ITEM ${number} (L${i + 2})`;
        }
        rows[i + 1] = [text, ""];
      }

      const page = e.offset / 5 + 1;
      let right = `P${page}  SAVE (R6)`;
      rows[5] = ["", right];
      return { title: "EDIT CHKLST", rows };
    }

    /* ========= Input handling ========= */

    /* Native keyboard → scratchpad synchronisation */
    scratchInput.addEventListener("input", () => {
      // Uppercase and limit length
      let val = scratchInput.value.toUpperCase().slice(0, 24);
      scratchInput.value = val;
      state.scratch = val;
      render();
    });

    scratchInput.addEventListener("focus", () => {
      // Place cursor at end
      const len = scratchInput.value.length;
      scratchInput.setSelectionRange(len, len);
    });

    function onKey(key) {
      if (key === "SP") {
        if (state.scratch.length < 24) state.scratch += " ";
      } else if (key === "CLR") {
        state.scratch = "";
      } else if (key === "DEL") {
        state.scratch = state.scratch.slice(0, -1);
      } else if (key === "EXEC") {
        // reserved; not needed
      } else if (key === "NEXT" || key === "PREV") {
        handlePageKey(key);
      } else if (key === "MENU") {
        setMenuPage();
        return;
      } else {
        if (state.scratch.length < 24) state.scratch += key;
      }
      // Keep input field in sync and focused
      scratchInput.value = state.scratch;
      scratchInput.focus();
      render();
    }

    function onLsk(side, idx) {
      switch (state.page) {
        case "MENU": handleMenuLsk(side, idx); break;
        case "SELECT": handleSelectLsk(side, idx); break;
        case "VIEW": handleViewLsk(side, idx); break;
        case "NEW": handleNewLsk(side, idx); break;
        case "EDIT": handleEditLsk(side, idx); break;
      }
      // After using LSKs, keep keyboard available but clear scratch when needed
      scratchInput.value = state.scratch;
      render();
    }

    /* --- LSK handlers per page --- */

    function handleMenuLsk(side, idx) {
      if (side === "R" && idx === 1) setSelectPage("view");
      else if (side === "R" && idx === 2) setNewPage();
      else if (side === "R" && idx === 3) setSelectPage("edit");
      else state.scratch = "NOT ALLOWED";
    }

    function handleSelectLsk(side, idx) {
      const sel = state.select;
      const files = state.checklists;
      if (side === "L" && idx === 6) { setMenuPage(); return; }
      if (side !== "L") { state.scratch = "NOT ALLOWED"; return; }

      if (idx >= 1 && idx <= 5) {
        const index = (sel.offset || 0) + (idx - 1);
        if (index < 0 || index >= files.length) {
          state.scratch = "NOT ALLOWED";
          return;
        }
        const id = files[index].id;
        if (sel.mode === "edit") setEditPage(id);
        else setViewPage(id);
      }
    }

    function handleViewLsk(side, idx) {
      const v = state.view;
      const cl = state.checklists.find(c => c.id === v.id);
      if (!cl) { setMenuPage(); return; }

      // L6: back to MENU
      if (side === "L" && idx === 6) {
        setMenuPage();
        return;
      }

      // L1..L5: toggle DONE
      if (side === "L" && idx >= 1 && idx <= 5) {
        const itemIndex = v.offset + (idx - 1);
        if (itemIndex >= 0 && itemIndex < cl.items.length) {
          v.checked[itemIndex] = !v.checked[itemIndex];
          state.scratch = "";
        } else {
          state.scratch = "NOT ALLOWED";
        }
      }
    }

    function handleNewLsk(side, idx) {
      const s = state.scratch.trim();
      const n = state.new;

      if (side === "L") {
        if (idx === 1) {
          if (!s) { state.scratch = "NO NAME"; return; }
          n.name = s;
          state.scratch = "";
          return;
        }
        if (idx >= 2 && idx <= 6) {
          if (!s) { state.scratch = "NO TEXT"; return; }
          const pos = n.offset + (idx - 2); // 0-based
          while (n.items.length <= pos) n.items.push("");
          n.items[pos] = s;
          state.scratch = "";
          return;
        }
      }

      if (side === "R" && idx === 6) {
        if (!n.name.trim()) {
          state.scratch = "NO NAME";
          return;
        }
        const newChecklist = {
          id: uuid(),
          name: n.name.trim(),
          items: n.items.slice()
        };
        state.checklists.push(newChecklist);
        saveChecklists();
        state.scratch = "SAVED";
        setMenuPage();
        return;
      }

      state.scratch = "NOT ALLOWED";
    }

    function handleEditLsk(side, idx) {
      const s = state.scratch.trim();
      const e = state.edit;

      if (side === "L") {
        if (idx === 1) {
          if (!s) { state.scratch = "NO NAME"; return; }
          e.name = s;
          state.scratch = "";
          return;
        }
        if (idx >= 2 && idx <= 6) {
          if (!s) { state.scratch = "NO TEXT"; return; }
          const pos = e.offset + (idx - 2);
          while (e.items.length <= pos) e.items.push("");
          e.items[pos] = s;
          state.scratch = "";
          return;
        }
      }

      if (side === "R" && idx === 6) {
        if (!e.name.trim()) {
          state.scratch = "NO NAME";
          return;
        }
        const idxCl = state.checklists.findIndex(c => c.id === e.id);
        if (idxCl !== -1) {
          state.checklists[idxCl] = {
            id: e.id,
            name: e.name.trim(),
            items: e.items.slice()
          };
          saveChecklists();
          state.scratch = "SAVED";
        }
        setMenuPage();
        return;
      }

      state.scratch = "NOT ALLOWED";
    }

    /* --- NEXT/PREV --- */
    function handlePageKey(key) {
      if (state.page === "SELECT") {
        const sel = state.select;
        const files = state.checklists;
        if (!files.length) return;
        if (key === "NEXT") {
          if (sel.offset + 5 < files.length) sel.offset += 5;
        } else if (key === "PREV") {
          if (sel.offset - 5 >= 0) sel.offset -= 5;
        }
      } else if (state.page === "VIEW") {
        const v = state.view;
        const cl = state.checklists.find(c => c.id === v.id);
        if (!cl) return;
        if (key === "NEXT") {
          if (v.offset + 5 < cl.items.length) v.offset += 5;
        } else if (key === "PREV") {
          if (v.offset - 5 >= 0) v.offset -= 5;
        }
      } else if (state.page === "NEW") {
        const n = state.new;
        if (key === "NEXT") {
          n.offset += 5;
        } else if (key === "PREV") {
          n.offset = Math.max(0, n.offset - 5);
        }
      } else if (state.page === "EDIT") {
        const e = state.edit;
        if (key === "NEXT") {
          e.offset += 5;
        } else if (key === "PREV") {
          e.offset = Math.max(0, e.offset - 5);
        }
      }
    }

    /* --- scratchpad info helper --- */
    function info(msg) {
      state.scratch = msg;
    }

    /* Boot */
    render();

    /* PWA service worker */
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch(() => { });
      });
    }
  </script>
</body>

</html>